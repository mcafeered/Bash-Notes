make multiple directories at once
mkdir $HOME/{1123,1134,1145,1156}

make multiple directories with defferent ascending numbers
mkdir $HOME/1123
touch $HOME/1123/{1..5}.txt $HOME/1123/{6..9}~.txt

find all files that have the .txt extension
find $HOME/1123 -name *.txt

copy all empty files that end in .txt to another directory
find $HOME/1123 ! -name *~.txt -name *.txt -exec cp {} $HOME/CUT/ \;

find empty files and print their names and inode numbers
find /var -empty -printf "%i %f\n"

find any file with a specic inode number and print it
find /* -inum 4026532575 -printf "%f\n"

using cut to get files that contain an extension and redirect them to another file
ls $HOME/CUT/ | cut -d. -f1- -s > $HOME/CUT/names

OR with ls -l 
ls -l $HOME/CUT | cut -d. -f1- -s | cut -d: -f1- -s | cut -d' ' -f2 > $HOME/CUT/names

greps only ip address and sorts them with counts
egrep -o "([0-9]{1,3}[\.]){3}[0-9]{1,3}" StoryHiddenIPs | sort -r | uniq -c | sort -r

script that extracts all names of users with a uid above 3 with /bin/bash as their shell
cat $HOME/passwd | grep '/bin/bash' | awk -F: '($3 > 4) {print $1}' > $HOME/SED/names.txt

OR

awk -F: '3 > 3 && $NF == "/bin/bash" {print $1}' $HOME/passwd > $HOME/SED/names.txt


finds specific errors in dmesg 
dmesg > dmesg.txt
grep 'CPU\|BIOS' dmesg.txt | grep -v 'usable\|reserved' | cut -d']' -f2-

generates an md5 hash password and replaces passwords in the shadow file
A=$(openssl passwd -1 -salt bad4u Password1234)
awk -F: -v "var=$A" 'BEGIN {OFS=":"} {$2=var} {print $0}' $HOME/PASS/shadow.txt

writing one file to another while ommiting some lines
sed '/\/bin\/false/d' $HOME/passwd | sed '/\/bin\/sh/d' > $HOME/PASS/passwd.txt
CAN USE -e between multiple patterns in sed 

can track and use argumens when making a script, reference special characters in Bash student guide for premade variables

example of basic script to use for reference:
  1 #!/bin/bash
  2 #this is a basic function
  3 
  4 function print_somefun {
  5     echo $*
  6 }
  7 
  8 somefun() {
  9     echo This is the first variable: $1
 10 }
 11 
 12 somefun Try this out $1 $2
 13 print_somefun $*

another one which returns the line count of a specified file
  1 #!/bin/bash
  2 
  3 lines_in_file() {
  4     cat $1 | wc -l
  5 }
  6 
  7 num_lines=$( lines_in_file $1)
  8 
  9 echo The file $1 has $num_lines lines in it
 10 echo Good Day Sir!

one more
  1 #!/bin/bash
  2 
  3 function f1 {
  4     echo 'Sup'
  5     echo 'nosup'
  6 }
  7 
  8 function f2 {
  9     echo 'sup 2'
 10     echo 'bye lol'
 11 }
 12 
 13 f3 () {
 14     echo 'stupid'
 15     echo 'gotem'
 16 }
 17 
 18 f4 () { echo 'im last'; echo 'or Am I'; }
 19 
 20 f1
 21 f2
 22 f3
 23 f4

different quotes like " and ' or a lack thereof affects how the program runs, like how single quotes prints the literal of a variable while double quotes actually prints the value stored in the variable
you can also use quotes like 'runnin around "lookin"' to put quotes within quotes (usage pending)

reference variable substitution for how to add or take values from variables, use colons to add, subtract, or remove values for the one particular instance where the variable is referenced

surprise if then script!
  1 #!/bin/bash
  2 
  3 function test_shadow () {
  4     if [ -e /etc/shadow ] ;
  5     then
  6         echo 'shadow exists'
  7     else
  8         echo 'shadow isnt found'
  9 fi
 10 }
 11 test_shadow

